<!DOCTYPE html>
<meta charset="utf-8">
<style>



</style>
<h1></h1></br>
 <svg width="600" height="400"></svg> 
<!-- svg width="2400" height="1600"></svg> -->
<script src="js/jquery-3.3.1.min.js"></script>
<script src="js/d3.v4.min.js"></script>
<script lang="javascript" src="data/synesthesia.js"></script>
<script>

// Transforms a CSV file to a plain text file
// Don't call this unless you want to process a csv file
function processCSVFile(){
    colors = [];
    csv_file = "data/onlyrgb.csv";
    d3.csv(csv_file,function(d){
        csv = d;
        num_ids = Object.keys(d).length - 1;
        var num_entries = Object.keys(d[0]).length;
        for(var i = 0; i < num_ids - 1; i++){
            colors[i] = [];
            keys = Object.keys(d[i]);
            for(var j = 0; j < num_entries; j++){
                //var letter = String.fromCharCode(Math.floor(j / 3) + "A".charCodeAt(0));c
                var letter = Math.floor(j/3);
                if(colors[i][letter] == null)
                    colors[i][letter] = {};
                if(j % 3 == 0){ // R
                    colors[i][letter]["R"] = parseFloat(csv[i][keys[j]]);
                }else if(j % 3 == 1){ // G
                    colors[i][letter]["G"] = parseFloat(csv[i][keys[j]]);
                }else{ // B
                    colors[i][letter]["B"] = parseFloat(csv[i][keys[j]]);
                    var hsv = rgb2hsv(colors[i][letter].R, colors[i][letter].G, colors[i][letter].B);
                    colors[i][letter]["H"] = hsv.h;
                    colors[i][letter]["S"] = hsv.s;
                    colors[i][letter]["V"] = hsv.v;
                }
                
            }
        }
        
        colors_string = JSON.stringify(colors)
            blob = new Blob([colors_string], { type: 'text/plain' }),
            anchor = document.createElement('a');

        anchor.download = "output.txt";
        anchor.href = (window.webkitURL || window.URL).createObjectURL(blob);
        anchor.dataset.downloadurl = ['text/plain', anchor.download, anchor.href].join(':');
        anchor.click();

    });
}
//https://stackoverflow.com/questions/8022885/rgb-to-hsv-color-in-javascript
function rgb2hsv (r, g, b) {
    var rr, gg, bb,
        /*
        r = arguments[0] / 255,
        g = arguments[1] / 255,
        b = arguments[2] / 255,
        */
        h, s,
        v = Math.max(r, g, b),
        diff = v - Math.min(r, g, b),
        diffc = function(c){
            return (v - c) / 6 / diff + 1 / 2;
        };

    if (diff == 0) {
        h = s = 0;
    } else {
        s = diff / v;
        rr = diffc(r);
        gg = diffc(g);
        bb = diffc(b);

        if (r === v) {
            h = bb - gg;
        }else if (g === v) {
            h = (1 / 3) + rr - bb;
        }else if (b === v) {
            h = (2 / 3) + gg - rr;
        }
        if (h < 0) {
            h += 1;
        }else if (h > 1) {
            h -= 1;
        }
    }
    return {
        h: Math.round(h * 360),
        s: Math.round(s * 100),
        v: Math.round(v * 100)
    };
}

function classifyColor(color, letter){
    letter_color_counts[letter][color] += 1;
    return color + " " + letter;
}

//http://bl.ocks.org/srosenthal/2770072
//https://stackoverflow.com/questions/46629188/multidimensional-array-for-d3
//https://zenodo.org/record/14285?fbclid=IwAR2tjoxmDO2rVjoiOopMJYaE6rd4THfhrWyGuYS_vfvOq6a5LxvcT3QFVGE
//https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0118996


data = colorData;
num_ids = data.length;
num_letters = 26;


var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height");
var width = +svg.attr("width");
var height = +svg.attr("height");


var num_rows = num_ids;
var num_cols = num_letters;
var rect_width = width / num_letters;
var rect_height = height / num_ids;
var local = d3.local();
var letters = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", 
                "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
var colors = ["white", "black", "gray", "red", "orange", "yellow", "green", "cyan", "blue", "purple", "pink"];
/*
var letter_color_counts = {};
letters.forEach(function(letter){
    letter_color_counts[letter] = {};
    colors.forEach(function(color){
        letter_color_counts[letter][color] = 0;
    });
});
*/


rects = svg
    .selectAll("rect")
    .data(data)
    .enter()
    .append("g")
    .selectAll("rect")
    .data(function (d, letter) {
        local.set(this, letter);
        return d;})
    .enter()
    .append("rect")
    .attr("x", function(d, letter){
        return letter*rect_width;
    })
    .attr("y", function(d, letter){
        var id = local.get(this);
        return id*rect_height;
    })
    .attr("height", rect_height)
    .attr("width", rect_width)
    /*
    .attr("fill", function(d, letter) {
        var id = local.get(this);
        var cellColor = data[id][letter];
        return `rgb(${cellColor.R * 255}, ${cellColor.G * 255}, ${cellColor.B * 255})`
    })
    */
    /*
    .on("mouseover", function(d, letter){
        console.log(this.getAttribute("class"));
    })
    */
    .attr("class", function(d, letter_code){
        var id = local.get(this);
        var base = "A".charCodeAt(0);
        var letter = String.fromCharCode(base + letter_code);
        /*
        var R = data[id][letter_code].R;
        var G = data[id][letter_code].G;
        var B = data[id][letter_code].B;
        var hsv = rgb2hsv(R,G,B);

        
        if (hsv.v < 20)  return classifyColor("black", letter);
        if (hsv.v > 90 && hsv.s < 10)  return classifyColor("white", letter);

        if (hsv.s < 25) return classifyColor("gray", letter);

        if (hsv.h < 30)   return classifyColor("red", letter);
        if (hsv.h < 60)   return classifyColor("orange", letter);
        if (hsv.h < 90)   return classifyColor("yellow", letter);
        if (hsv.h < 150)  return classifyColor("green", letter);
        if (hsv.h < 210)  return classifyColor("cyan", letter);
        if (hsv.h < 270)  return classifyColor("blue", letter);
        if (hsv.h < 320)  return classifyColor("purple", letter);
        if (hsv.h < 335)  return classifyColor("pink", letter);
        return classifyColor("red", letter);
        */
        var cellColor = data[id][letter_code];
        if (cellColor.V < 20)  return "black " + letter;
        if (cellColor.V > 90 && cellColor.S < 10)  return "white " + letter;

        if (cellColor.S < 25) return "gray " + letter;

        if (cellColor.H < 30)   return "red " + letter;
        if (cellColor.H < 60)   return "orange " + letter;
        if (cellColor.H < 90)   return "yellow " + letter;
        if (cellColor.H < 150)  return "green " + letter;
        if (cellColor.H < 210)  return "cyan " + letter;
        if (cellColor.H < 270)  return "blue " + letter;
        if (cellColor.H < 320)  return "purple " + letter;
        if (cellColor.H < 335)  return "pink " + letter;
        return "red " + letter;
    });





</script>
